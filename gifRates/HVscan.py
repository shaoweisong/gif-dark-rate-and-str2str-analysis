# python plot_2D_HV_darkrate_charge_test.py --tenpctzero --tmb0v me11_txt/TMB_0V_me11_2pct_new.txt --tmbhv0 me11_txt/TMB_HV0_me11_2pct_new.txt --data me11_txt/anode_me11_2pct_hv0.txt --chambtype 1 --name hv_alct_me11 --hv0file me11_corrroot/anode_me11_2pct_test.txt
import argparse, array
from ROOT import gROOT, TCanvas, TLegend, TGraphErrors, TDatime, TH2F, gStyle, kYellow, kCyan, kRed, kGreen, kOrange, kViolet, TMath, gPad, TFile, TPaletteAxis,TH2F
#from datetime import datetime
gStyle.SetOptStat(0)
gStyle.SetPalette(1)
from datetime import datetime


parser = argparse.ArgumentParser(description='plot TMB Dump results over time for a chosen CLCT. Input text files generated by dumping output of TMB_AG.py to text file. Before running this be sure to manually check input for errors in database or measurement outliers & remove/correct them accordingly. \n Please also ensure that each HV0 measurement has exactly one corresponding 0V measurement and vice versa.\n As of writing the goal is to look at measurements from Sept 2017 onwards.')
parser.add_argument('--clctnum', action='store', default=16, type=int, help=" Available numbers are 14-20 \n DEFAULT: 16")
parser.add_argument('--startdate', action='store', default="01 SEP 2015", type=str, help="Starting date: write as DD MTH YYYY where MTH is the 3 letter abbreviation for the month\n DEFAULT: 01 SEP 2017")
parser.add_argument('--timeplot', action='store_true', default=False, help="Plot with time as the x axis as opposed to charge\n DEFAULT: False")
parser.add_argument('--tenpctzero', action='store_true', help=" Plotting over the entire region of charge accumulation or just for 2 percent CF4\n DEFAULT: False")
parser.add_argument('--validatewithold', action='store_true',default = False, help=" For validating with Long Wang's Old Results\n DEFAULT: False")
parser.add_argument('--plotproblem', action='store_true', help=" Plot problem WG 5 in layer 5 me11 vs normal WG 4\n DEFAULT: False")
parser.add_argument('--plotcathodes', action='store_true', help="Show CFEB and CLCT plots or no\n DEFAULT: False")
parser.add_argument('--plotname', action='store', type=str, default='Sept17-Jun21', help="Name of output plots\n DEFAULT: Sept17-Jun21")
parser.add_argument('--test11compare', action='store_true', help="for comparing test 11 ALCT rates with TMB dump ALCT rates (By default this macro still uses test 11 to correct for noisy wg in layer 5 regardless of this value)\n DEFAULT: False")
parser.add_argument('--charges', action ='store', default='charges_me11_all.txt', type=str, help="list of charges - 'outfile' from getcharges.py\n DEFAULT: charges_me11_all.txt")
parser.add_argument('--DatHV0', action ='store', default='TMB_HV0_me11_all.txt', type=str, help="of HV0 TMB Dump measurements\n DEFAULT: TMB_HV0_me11_all.txt")
parser.add_argument('--Dat3000', action ='store', default='TMB_HV0_me11_all.txt', type=str, help="of HV0 TMB Dump measurements\n DEFAULT: TMB_HV0_me11_all.txt")
parser.add_argument('--Dat2950', action ='store', default='TMB_HV0_me11_all.txt', type=str, help="of HV0 TMB Dump measurements\n DEFAULT: TMB_HV0_me11_all.txt")
parser.add_argument('--Dat2900', action ='store', default='TMB_HV0_me11_all.txt', type=str, help="of HV0 TMB Dump measurements\n DEFAULT: TMB_HV0_me11_all.txt")
parser.add_argument('--Dat2800', action ='store', default='TMB_HV0_me11_all.txt', type=str, help="of HV0 TMB Dump measurements\n DEFAULT: TMB_HV0_me11_all.txt")
parser.add_argument('--Dat0V', action ='store', default='TMB_0V_me11_all.txt', type=str, help="list of 0V TMB Dump measurements\n DEFAULT: TMB_0V_me11_all.txt")
parser.add_argument('--DatT11', action ='store', default='anode_me11_all.txt', type=str, help="list of Test 11 measurements\n DEFAULT: anode_me11_all.txt")
parser.add_argument('--LowHV', action='store_true', default=False, help="HV scan for low HV(2800)")
args = parser.parse_args()

if args.tenpctzero:
    plus300 = True
else:
    plus300 = False

starttime = datetime.strptime(args.startdate, "%d %b %Y")
tmbdump_0v = []
tmbdump_hv0 = []
tmbdump_3000 = []
tmbdump_2950 = []
tmbdump_2900 = []
tmbdump_2800 = []
CLCT_NUM = args.clctnum - 5
numlines_0v = sum(1 for line in open(args.Dat0V))
numlines_hv0 = sum(1 for line in open(args.DatHV0))
numlines_3000 = sum(1 for line in open(args.Dat3000))
numlines_2950 = sum(1 for line in open(args.Dat2950))
numlines_2900 = sum(1 for line in open(args.Dat2900))
numlines_2800 = sum(1 for line in open(args.Dat2800))
rootfiles = []

with open(args.Dat0V, "r") as f0:
    for linenum, line in enumerate(f0):
        #skip preamble
        if linenum <= 5:
            continue
        #debug statement
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Input CLCT number, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                line_arr += [float(item)]
        tmbdump_0v += [line_arr]
    f0.close()

def GetTotalCorrectedRate(rootfilename):
    summedhits = 0
    corrections = 0
    rootfile = TFile(rootfilename, "read")
    for layernum in xrange(0,6):
        hname = str("ALCT/hNofAhitL["+str(layernum)+"][2]")
        hist = rootfile.Get(hname)
        if hist != 0:
            entries = hist.GetEntries()
            summedhits += entries
    hist2 = rootfile.Get("ALCT/hNofAhit[2]")
    for binnum in xrange(2, 8):
        NumOfLayers = binnum - 2
        NHits = hist2.GetBinContent(binnum)
        LayerCorrection = 0
        if NumOfLayers != 0:
            LayerCorrection = NHits * (NumOfLayers - 1) / NumOfLayers
        corrections += LayerCorrection
    CorrectedTotalRate = (summedhits - corrections) / 30
    rootfile.Close()
    return CorrectedTotalRate
with open(args.DatHV0, "r") as f1:
    for linenum, line in enumerate(f1):
        #skip preamble
        if linenum <= 5:
            continue
        #if linenum == 20 or linenum == 21 or linenum == 22:
        #    print line
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Chosen CLCT, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                #if (linenum == 20 or linenum == 21 or linenum == 22) and (index == 16 or index == 9 or index == 10):
                #    print titleline.split()[index-1]
                #    print item
                line_arr += [float(item)]
        tmbdump_hv0 += [line_arr]
    f1.close()
with open(args.Dat3000, "r") as f1:
    for linenum, line in enumerate(f1):
        #skip preamble
        if linenum <= 5:
            continue
        #if linenum == 20 or linenum == 21 or linenum == 22:
        #    print line
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Chosen CLCT, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                #if (linenum == 20 or linenum == 21 or linenum == 22) and (index == 16 or index == 9 or index == 10):
                #    print titleline.split()[index-1]
                #    print item
                line_arr += [float(item)]
        tmbdump_3000 += [line_arr]
    f1.close()
with open(args.Dat2950, "r") as f1:
    for linenum, line in enumerate(f1):
        #skip preamble
        if linenum <= 5:
            continue
        #if linenum == 20 or linenum == 21 or linenum == 22:
        #    print line
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Chosen CLCT, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                #if (linenum == 20 or linenum == 21 or linenum == 22) and (index == 16 or index == 9 or index == 10):
                #    print titleline.split()[index-1]
                #    print item
                line_arr += [float(item)]
        tmbdump_2950 += [line_arr]
    f1.close()
with open(args.Dat2900, "r") as f1:
    for linenum, line in enumerate(f1):
        #skip preamble
        if linenum <= 5:
            continue
        #if linenum == 20 or linenum == 21 or linenum == 22:
        #    print line
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Chosen CLCT, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                #if (linenum == 20 or linenum == 21 or linenum == 22) and (index == 16 or index == 9 or index == 10):
                #    print titleline.split()[index-1]
                #    print item
                line_arr += [float(item)]
        tmbdump_2900 += [line_arr]
    f1.close()
with open(args.Dat2800, "r") as f1:
    for linenum, line in enumerate(f1):
        #skip preamble
        if linenum <= 5:
            continue
        #if linenum == 20 or linenum == 21 or linenum == 22:
        #    print line
        #if linenum == 15:
        #    break
        line_arr = []
        for index, item in enumerate(line.split()):
            #skip database number, comma and UTC time of measurement [included with date as single string], srcdwn, L1A, and comment
            #output vector will have [datime, HV, t[sec], 0ALCT, 13CLCT (aka the CFEB, which should sum all the values from the CLCTs), Chosen CLCT, TMB]
            if index == 0 or index == 2 or index == 3 or index == 5 or index >= 17:
                continue
            #take only the chosen cfeb
            if index != CLCT_NUM and index > 8 and index <= 15:
                continue
            if index == 1:
                #keep date as a string
                datime = str(item + line.split()[2] + ' ' + line.split()[3])
                line_arr += [datime]
            elif index == 4:
                #Keep voltage setup as a string
                line_arr += [str(item)]
            else: 
                #if (linenum == 20 or linenum == 21 or linenum == 22) and (index == 16 or index == 9 or index == 10):
                #    print titleline.split()[index-1]
                #    print item
                line_arr += [float(item)]
        tmbdump_2800 += [line_arr]
    f1.close()

if args.test11compare:
    t11fullCorralctrates = []
rootfiles = []
date = []
with open(args.DatT11, "r") as f1:
    for lnum, line in enumerate(f1):
        if lnum == 0: continue
        rootfiles += [str(line.split()[0])]
        date += [str(line.split()[2])]
        if args.test11compare:
            t11fullCorralctrates += [GetTotalCorrectedRate(rootfiles[-1])]
    f1.close()
corralcthv0=[]
corralct3000=[]
corralct2950=[]
corralct2900=[]
corralct2800=[]

for i in xrange(len(tmbdump_hv0)):
    pydt = datetime.strptime(tmbdump_hv0[i][0], "%d-%b-%Y, %H:%M:%S") 
    pydt_ = datetime.strptime(tmbdump_0v[i][0], "%d-%b-%Y, %H:%M:%S") 
    if (abs(pydt_-pydt).seconds/3600 > 24):
        print "Too large time difference between 0v and HV0 measurements at", tmbdump_hv0[i][0]
        quit()
    if pydt_ < starttime:
        continue
    thv0 = float(tmbdump_hv0[i][2])
    t0v = float(tmbdump_0v[i][2])
    if thv0 == 0 or t0v == 0:
        print "Time error for measurement at: ", tmbdump_0v[i][0]
        quit()
    alct = tmbdump_hv0[i][3]/thv0 - tmbdump_0v[i][3]/t0v
    t11file = TFile(rootfiles[i], "read")
    if args.test11compare:
        t11alct = t11fullCorralctrates[i]
        t11alct0 = t11file.Get("ALCT/hNofAhit[2]").GetBinContent(3)/30.0
    else:
        t11hist = t11file.Get("ALCT/hAhitL[4][1]")
        #The bad WG is 5, but histogram bins start counting from 1 (the first bin would be at zero) and in addition the WG start counting at 1 - with bin 1 left empty, so 2 is added to the desired wg to get the index.
        l5bad = t11hist.GetBinContent(7)/30
        l5good = t11hist.GetBinContent(8)/30
        corralct = alct - l5bad + l5good
        if args.plotcathodes:
            cfeb = tmbdump_hv0[i][4]/thv0 - tmbdump_0v[i][4]/t0v
            clct = tmbdump_hv0[i][5]/thv0 - tmbdump_0v[i][5]/t0v
    tmb = tmbdump_hv0[i][6]/thv0 - tmbdump_0v[i][6]/t0v
    corrtmb=tmb
    if corrtmb > corralct:
        corrtmb = corralct -50
    if corrtmb<0:
        corrtmb = corralct 
    if args.LowHV:
        corralct = alct
        corrtmb = tmb
    corralcthv0.append(corralct)
for i in xrange(len(tmbdump_3000)):
    pydt = datetime.strptime(tmbdump_3000[i][0], "%d-%b-%Y, %H:%M:%S") 
    pydt_ = datetime.strptime(tmbdump_0v[i][0], "%d-%b-%Y, %H:%M:%S") 
    if (abs(pydt_-pydt).seconds/3600 > 24):
        print "Too large time difference between 0v and 3000 measurements at", tmbdump_3000[i][0]
        quit()
    if pydt_ < starttime:
        continue
    t3000 = float(tmbdump_3000[i][2])
    t0v = float(tmbdump_0v[i][2])
    if t3000 == 0 or t0v == 0:
        print "Time error for measurement at: ", tmbdump_0v[i][0]
        quit()
    alct = tmbdump_3000[i][3]/t3000 - tmbdump_0v[i][3]/t0v
    t11file = TFile(rootfiles[i], "read")
    if args.test11compare:
        t11alct = t11fullCorralctrates[i]
        t11alct0 = t11file.Get("ALCT/hNofAhit[2]").GetBinContent(3)/30.0
    else:
        t11hist = t11file.Get("ALCT/hAhitL[4][1]")
        #The bad WG is 5, but histogram bins start counting from 1 (the first bin would be at zero) and in addition the WG start counting at 1 - with bin 1 left empty, so 2 is added to the desired wg to get the index.
        l5bad = t11hist.GetBinContent(7)/30
        l5good = t11hist.GetBinContent(8)/30
        corralct = alct - l5bad + l5good
        if args.plotcathodes:
            cfeb = tmbdump_3000[i][4]/t3000 - tmbdump_0v[i][4]/t0v
            clct = tmbdump_3000[i][5]/t3000 - tmbdump_0v[i][5]/t0v
    tmb = tmbdump_3000[i][6]/t3000 - tmbdump_0v[i][6]/t0v
    corrtmb=tmb
    if corrtmb > corralct:
        corrtmb = corralct -50
    if corrtmb<0:
        corrtmb = corralct 
    if args.LowHV:
        corralct = alct
        corrtmb = tmb
    corralct3000.append(corralct)
for i in xrange(len(tmbdump_2950)):
    pydt = datetime.strptime(tmbdump_2950[i][0], "%d-%b-%Y, %H:%M:%S") 
    pydt_ = datetime.strptime(tmbdump_0v[i][0], "%d-%b-%Y, %H:%M:%S") 
    if (abs(pydt_-pydt).seconds/3600 > 24):
        print "Too large time difference between 0v and 2950 measurements at", tmbdump_2950[i][0]
        quit()
    if pydt_ < starttime:
        continue
    t2950 = float(tmbdump_2950[i][2])
    t0v = float(tmbdump_0v[i][2])
    if t2950 == 0 or t0v == 0:
        print "Time error for measurement at: ", tmbdump_0v[i][0]
        quit()
    alct = tmbdump_2950[i][3]/t2950 - tmbdump_0v[i][3]/t0v
    t11file = TFile(rootfiles[i], "read")
    if args.test11compare:
        t11alct = t11fullCorralctrates[i]
        t11alct0 = t11file.Get("ALCT/hNofAhit[2]").GetBinContent(3)/30.0
    else:
        t11hist = t11file.Get("ALCT/hAhitL[4][1]")
        #The bad WG is 5, but histogram bins start counting from 1 (the first bin would be at zero) and in addition the WG start counting at 1 - with bin 1 left empty, so 2 is added to the desired wg to get the index.
        l5bad = t11hist.GetBinContent(7)/30
        l5good = t11hist.GetBinContent(8)/30
        corralct = alct - l5bad + l5good
        if args.plotcathodes:
            cfeb = tmbdump_2950[i][4]/t2950 - tmbdump_0v[i][4]/t0v
            clct = tmbdump_2950[i][5]/t2950 - tmbdump_0v[i][5]/t0v
    tmb = tmbdump_2950[i][6]/t2950 - tmbdump_0v[i][6]/t0v
    corrtmb=tmb
    if corrtmb > corralct:
        corrtmb = corralct -50
    if corrtmb<0:
        corrtmb = corralct 
    if args.LowHV:
        corralct = alct
        corrtmb = tmb
    corralct2950.append(corralct)

for i in xrange(len(tmbdump_2900)):
    pydt = datetime.strptime(tmbdump_2900[i][0], "%d-%b-%Y, %H:%M:%S") 
    pydt_ = datetime.strptime(tmbdump_0v[i][0], "%d-%b-%Y, %H:%M:%S") 
    if (abs(pydt_-pydt).seconds/3600 > 24):
        print "Too large time difference between 0v and 2900 measurements at", tmbdump_2900[i][0]
        quit()
    if pydt_ < starttime:
        continue
    t2900 = float(tmbdump_2900[i][2])
    t0v = float(tmbdump_0v[i][2])
    if t2900 == 0 or t0v == 0:
        print "Time error for measurement at: ", tmbdump_0v[i][0]
        quit()
    alct = tmbdump_2900[i][3]/t2900 - tmbdump_0v[i][3]/t0v
    t11file = TFile(rootfiles[i], "read")
    if args.test11compare:
        t11alct = t11fullCorralctrates[i]
        t11alct0 = t11file.Get("ALCT/hNofAhit[2]").GetBinContent(3)/30.0
    else:
        t11hist = t11file.Get("ALCT/hAhitL[4][1]")
        #The bad WG is 5, but histogram bins start counting from 1 (the first bin would be at zero) and in addition the WG start counting at 1 - with bin 1 left empty, so 2 is added to the desired wg to get the index.
        l5bad = t11hist.GetBinContent(7)/30
        l5good = t11hist.GetBinContent(8)/30
        corralct = alct - l5bad + l5good
        if args.plotcathodes:
            cfeb = tmbdump_2900[i][4]/t2900 - tmbdump_0v[i][4]/t0v
            clct = tmbdump_2900[i][5]/t2900 - tmbdump_0v[i][5]/t0v
    tmb = tmbdump_2900[i][6]/t2900 - tmbdump_0v[i][6]/t0v
    corrtmb=tmb
    if corrtmb > corralct:
        corrtmb = corralct -50
    if corrtmb<0:
        corrtmb = corralct 
    if args.LowHV:
        corralct = alct
        corrtmb = tmb
    corralct2900.append(corralct)
for i in xrange(len(tmbdump_2800)):
    pydt = datetime.strptime(tmbdump_2800[i][0], "%d-%b-%Y, %H:%M:%S") 
    pydt_ = datetime.strptime(tmbdump_0v[i][0], "%d-%b-%Y, %H:%M:%S") 
    if (abs(pydt_-pydt).seconds/3600 > 24):
        print "Too large time difference between 0v and 2800 measurements at", tmbdump_2800[i][0]
        quit()
    if pydt_ < starttime:
        continue
    t2800 = float(tmbdump_2800[i][2])
    t0v = float(tmbdump_0v[i][2])
    if t2800 == 0 or t0v == 0:
        print "Time error for measurement at: ", tmbdump_0v[i][0]
        quit()
    alct = tmbdump_2800[i][3]/t2800 - tmbdump_0v[i][3]/t0v
    t11file = TFile(rootfiles[i], "read")
    if args.test11compare:
        t11alct = t11fullCorralctrates[i]
        t11alct0 = t11file.Get("ALCT/hNofAhit[2]").GetBinContent(3)/30.0
    else:
        t11hist = t11file.Get("ALCT/hAhitL[4][1]")
        #The bad WG is 5, but histogram bins start counting from 1 (the first bin would be at zero) and in addition the WG start counting at 1 - with bin 1 left empty, so 2 is added to the desired wg to get the index.
        l5bad = t11hist.GetBinContent(7)/30
        l5good = t11hist.GetBinContent(8)/30
        corralct = alct - l5bad + l5good
        if args.plotcathodes:
            cfeb = tmbdump_2800[i][4]/t2800 - tmbdump_0v[i][4]/t0v
            clct = tmbdump_2800[i][5]/t2800 - tmbdump_0v[i][5]/t0v
    tmb = tmbdump_2800[i][6]/t2800 - tmbdump_0v[i][6]/t0v
    corrtmb=tmb
    corralct2800.append(alct)

qtot = []
# importing charge data for me11 - check with time consistency already done by getcharges.py
with open(args.charges, "r") as f2:
    for linenum, line in enumerate(f2):
        if args.tenpctzero:
            qtot += [float(line)+0]
        else:
            qtot += [float(line)]
    f2.close()
if len(qtot) != len(tmbdump_0v):
    print "ERROR: mismatch in number of charge measurements and number of TMB dump measurements"
    print "TMB: ", len(tmbdump_0v)
    print "Charge: ", len(qtot)
    quit()


corralct_lists = [corralcthv0, corralct2900, corralct2950, corralct3000]
y_labels = ["hv0", "2900", "2950", "3000"]

nX = len(qtot)
nY = len(corralct_lists)

c = TCanvas("c", "c", 800, 600)

h2 = TH2F("h2", "Anode Corrected ALCT Dark Rate; Accumulated charge [mC/cm]; HV setting", nX, 0, nX, nY, 0, nY)

for iy, y_index in enumerate(range(nY)):
    for ix, x_index in enumerate(range(nX)):
        z = corralct_lists[iy][ix]
        h2.SetBinContent(ix + 1, iy + 1, z)

for ix, label in enumerate(qtot):
    if ix in [0, len(qtot)//2, len(qtot)-1]: 
        h2.GetXaxis().SetBinLabel(ix + 1, str(label))
    else:
        h2.GetXaxis().SetBinLabel(ix + 1, "")

for iy, label in enumerate(y_labels):
    h2.GetYaxis().SetBinLabel(iy + 1, label)
gPad.SetRightMargin(0.15)  

gStyle.SetOptStat(0)
gStyle.SetPalette(1) 
h2.GetXaxis().LabelsOption("h")
h2.SetMinimum(500)
# h2.SetMaximum(5000)
h2.SetMaximum(500000)
h2.GetZaxis().SetTitle("Hz")

h2.Draw("COLZ")  
c.SaveAs("HVscan.pdf")
